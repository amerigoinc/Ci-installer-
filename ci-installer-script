#!/usr/bin/env python3
"""
ğŸŒ CI Package Manager - AmerigoInc
One-Time Install: python3 ci-installer.py
Then: ci install <package> (works anywhere forever)
Clones from: https://github.com/amerigoinc
"""

import os
import sys
import json
import shutil
import subprocess
from pathlib import Path

class CIInstaller:
    def __init__(self):
        self.home = Path.home()
        self.ci_dir = self.home / ".ci"
        self.packages_dir = self.ci_dir / "packages"
        self.bin_dir = self.ci_dir / "bin"
        self.config_file = self.ci_dir / "ci-config.json"
        
        # AmerigoInc GitHub organization
        self.org_name = "amerigoinc"
        self.base_url = f"https://github.com/{self.org_name}"
        
    def ensure_directories(self):
        """Create necessary directories"""
        self.ci_dir.mkdir(exist_ok=True)
        self.packages_dir.mkdir(parents=True, exist_ok=True)
        self.bin_dir.mkdir(exist_ok=True)
        
    def load_config(self):
        """Load or create configuration"""
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return json.load(f)
        return {
            "installed_packages": {},
            "organization": self.org_name,
            "version": "1.0.0"
        }
    
    def save_config(self, config):
        """Save configuration"""
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
    
    def install_ci_system(self):
        """Install CI as a permanent system command"""
        print("ğŸš€ Installing CI Package Manager for AmerigoInc...")
        print(f"ğŸ“¦ Packages will be cloned from: {self.base_url}")
        
        # Determine install location
        install_locations = [
            "/usr/local/bin/ci",
            f"{self.home}/.local/bin/ci", 
            f"{self.home}/bin/ci"
        ]
        
        installed = False
        for install_path in install_locations:
            try:
                install_dir = Path(install_path).parent
                install_dir.mkdir(parents=True, exist_ok=True)
                
                # Create the CI manager script
                self.create_ci_manager_script(install_path)
                
                # Make executable
                os.chmod(install_path, 0o755)
                
                print(f"âœ… CI installed to: {install_path}")
                
                # Ensure PATH
                self.ensure_path(install_dir)
                
                self.ensure_directories()
                
                # Save initial config
                config = self.load_config()
                self.save_config(config)
                
                installed = True
                break
                
            except PermissionError:
                continue
            except Exception as e:
                continue
        
        if not installed:
            # Try with sudo
            print("ğŸ”’ Trying with sudo...")
            try:
                subprocess.run([
                    "sudo", "cp", __file__, "/usr/local/bin/ci"
                ], check=True)
                subprocess.run([
                    "sudo", "chmod", "+x", "/usr/local/bin/ci"
                ], check=True)
                print("âœ… CI installed to: /usr/local/bin/ci")
                installed = True
            except:
                print("âŒ Please run: sudo python3 ci-installer.py")
                return False
        
        return installed
    
    def create_ci_manager_script(self, install_path):
        """Create the permanent CI manager script"""
        ci_script = f'''#!/usr/bin/env python3
import os
import sys
import json
import shutil
import subprocess
from pathlib import Path

class CIPackageManager:
    def __init__(self):
        self.home = Path.home()
        self.ci_dir = self.home / ".ci"
        self.packages_dir = self.ci_dir / "packages"
        self.bin_dir = self.ci_dir / "bin"
        self.config_file = self.ci_dir / "ci-config.json"
        self.org_name = "amerigoinc"
        self.base_url = "https://github.com/amerigoinc"
    
    def load_config(self):
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return json.load(f)
        return {{"installed_packages": {{}}}}
    
    def save_config(self, config):
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
    
    def check_repo_exists(self, package_name):
        """Check if repository exists in AmerigoInc"""
        try:
            result = subprocess.run([
                "git", "ls-remote", f"https://github.com/amerigoinc/{{package_name}}.git"
            ], capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except:
            return False
    
    def install(self, package_name):
        print(f"ğŸ”§ Installing {{package_name}} from AmerigoInc...")
        
        # Check if repo exists
        if not self.check_repo_exists(package_name):
            print(f"âŒ Package '{{package_name}}' not found in AmerigoInc")
            print(f"   Check: https://github.com/amerigoinc/{{package_name}}")
            return False
        
        config = self.load_config()
        
        if package_name in config.get("installed_packages", {{}}):
            print("ğŸ”„ Package exists, updating...")
            return self.update(package_name)
        
        repo_url = f"https://github.com/amerigoinc/{{package_name}}.git"
        package_dir = self.packages_dir / package_name
        
        try:
            # Clone repository
            print(f"ğŸ“¥ Cloning from {{repo_url}}...")
            result = subprocess.run(
                ["git", "clone", repo_url, str(package_dir)],
                capture_output=True, text=True, check=True
            )
            
            # Verify CI package structure
            spec_file = package_dir / "spec.ci"
            if not spec_file.exists():
                print(f"âŒ {{package_name}} is not a CI package (missing spec.ci)")
                print("   Repository must contain spec.ci file")
                shutil.rmtree(package_dir)
                return False
            
            # Process package
            success = self.process_package(package_dir, package_name)
            if success:
                config["installed_packages"][package_name] = {{
                    "version": "latest",
                    "path": str(package_dir),
                    "repo": repo_url
                }}
                self.save_config(config)
                print(f"âœ… {{package_name}} installed successfully!")
                self.show_usage(package_dir)
            
            return success
            
        except subprocess.CalledProcessError as e:
            print(f"âŒ Failed to install {{package_name}}")
            print(f"   Error: {{e.stderr}}")
            return False
    
    def update(self, package_name):
        package_dir = self.packages_dir / package_name
        if not package_dir.exists():
            return self.install(package_name)
        
        try:
            print(f"ğŸ”„ Updating {{package_name}}...")
            result = subprocess.run(
                ["git", "-C", str(package_dir), "pull", "--ff-only"],
                capture_output=True, text=True, check=True
            )
            self.process_package(package_dir, package_name)
            print(f"âœ… {{package_name}} updated!")
            return True
        except subprocess.CalledProcessError as e:
            print(f"âŒ Failed to update {{package_name}}")
            return False
    
    def process_package(self, package_dir, package_name):
        """Make main files executable and create symlinks"""
        spec_file = package_dir / "spec.ci"
        if not spec_file.exists():
            return False
        
        with open(spec_file, 'r') as f:
            spec = json.load(f)
        
        # Make main files executable and link them
        main_files = spec.get("main_files", [])
        linked_files = []
        
        for main_file in main_files:
            file_path = package_dir / main_file
            if file_path.exists():
                # Make executable
                file_path.chmod(0o755)
                
                # Create symlink in bin directory
                bin_link = self.bin_dir / main_file
                if bin_link.exists():
                    bin_link.unlink()
                bin_link.symlink_to(file_path)
                linked_files.append(main_file)
                print(f"  ğŸ”— {{main_file}}")
            else:
                print(f"  âš ï¸  Main file not found: {{main_file}}")
        
        # Run setup commands
        setup_file = package_dir / "setup.json"
        if setup_file.exists():
            self.run_setup(setup_file, package_dir)
        
        return len(linked_files) > 0
    
    def run_setup(self, setup_file, package_dir):
        """Run post-install setup commands"""
        with open(setup_file, 'r') as f:
            setup = json.load(f)
        
        commands = setup.get("post_install", [])
        for cmd in commands:
            try:
                print(f"  ğŸ› ï¸  Running: {{cmd}}")
                result = subprocess.run(
                    cmd, shell=True, cwd=package_dir, 
                    capture_output=True, text=True
                )
                if result.returncode != 0:
                    print(f"  âš ï¸  Command failed: {{cmd}}")
            except Exception as e:
                print(f"  âš ï¸  Error: {{e}}")
    
    def show_usage(self, package_dir):
        """Show available commands after installation"""
        spec_file = package_dir / "spec.ci"
        if spec_file.exists():
            with open(spec_file, 'r') as f:
                spec = json.load(f)
            main_files = spec.get("main_files", [])
            if main_files:
                print(f"ğŸš€ Now available globally:")
                for mf in main_files:
                    print(f"   $ {{mf}}")
    
    def list(self):
        """List all installed packages"""
        config = self.load_config()
        packages = config.get("installed_packages", {{}})
        
        if not packages:
            print("No packages installed from AmerigoInc")
            return
        
        print("ğŸ“¦ Installed packages from AmerigoInc:")
        for pkg, info in packages.items():
            print(f"  â€¢ {{pkg}}")
            spec_file = self.packages_dir / pkg / "spec.ci"
            if spec_file.exists():
                with open(spec_file, 'r') as f:
                    spec = json.load(f)
                main_files = spec.get("main_files", [])
                for mf in main_files:
                    bin_path = self.bin_dir / mf
                    if bin_path.exists():
                        print(f"    â””â”€ {{mf}}")
    
    def remove(self, package_name):
        """Remove an installed package"""
        config = self.load_config()
        
        if package_name not in config.get("installed_packages", {{}}):
            print(f"âŒ {{package_name}} not found in installed packages")
            return False
        
        package_dir = self.packages_dir / package_name
        
        # Remove linked binaries
        spec_file = package_dir / "spec.ci"
        if spec_file.exists():
            with open(spec_file, 'r') as f:
                spec = json.load(f)
            for main_file in spec.get("main_files", []):
                bin_link = self.bin_dir / main_file
                if bin_link.exists():
                    bin_link.unlink()
                    print(f"  ğŸ—‘ï¸  Removed: {{main_file}}")
        
        # Remove package directory
        if package_dir.exists():
            shutil.rmtree(package_dir)
        
        # Update config
        config["installed_packages"].pop(package_name, None)
        self.save_config(config)
        
        print(f"âœ… {{package_name}} removed successfully!")
        return True
    
    def info(self, package_name):
        """Show information about a package"""
        package_dir = self.packages_dir / package_name
        spec_file = package_dir / "spec.ci"
        
        if not spec_file.exists():
            print(f"âŒ {{package_name}} not found or not a CI package")
            return False
        
        with open(spec_file, 'r') as f:
            spec = json.load(f)
        
        print(f"ğŸ“‹ Package: {{package_name}}")
        print(f"ğŸ“– Description: {{spec.get('description', 'No description')}}")
        print(f"ğŸ”„ Version: {{spec.get('version', 'Unknown')}}")
        print(f"ğŸš€ Available commands:")
        for mf in spec.get("main_files", []):
            bin_path = self.bin_dir / mf
            status = "âœ…" if bin_path.exists() else "âŒ"
            print(f"   {{status}} {{mf}}")
    
    def search(self, query=None):
        """Search for packages in AmerigoInc (basic implementation)"""
        print(f"ğŸ” Searching AmerigoInc for packages...")
        print(f"ğŸŒ Visit: https://github.com/amerigoinc")
        print("   (Advanced search requires GitHub API integration)")
        
        # Simple message - can be enhanced with GitHub API
        config = self.load_config()
        installed = list(config.get("installed_packages", {{}}).keys())
        if installed:
            print(f"ğŸ“¦ Your installed packages: {{', '.join(installed)}}")

def main():
    if len(sys.argv) < 2:
        print("ğŸŒ CI Package Manager - AmerigoInc")
        print("Usage: ci <command> [package]")
        print("")
        print("Commands:")
        print("  install <package>  - Install package from AmerigoInc")
        print("  remove <package>   - Remove installed package")
        print("  list              - List installed packages")
        print("  update <package>   - Update package (or 'all')")
        print("  info <package>     - Show package information")
        print("  search [query]     - Search for packages")
        print("")
        print("Examples:")
        print("  ci install image-tools     # Install from amerigoinc/image-tools")
        print("  ci list                    # Show installed packages")
        print("  ci update all              # Update all packages")
        print("  ci remove old-package      # Remove package")
        sys.exit(1)
    
    manager = CIPackageManager()
    command = sys.argv[1]
    
    if command == "install" and len(sys.argv) > 2:
        manager.install(sys.argv[2])
    elif command == "remove" and len(sys.argv) > 2:
        manager.remove(sys.argv[2])
    elif command == "list":
        manager.list()
    elif command == "update":
        if len(sys.argv) > 2:
            if sys.argv[2] == "all":
                config = manager.load_config()
                for pkg in config.get("installed_packages", {{}}):
                    manager.update(pkg)
            else:
                manager.update(sys.argv[2])
        else:
            print("Usage: ci update <package> or ci update all")
    elif command == "info" and len(sys.argv) > 2:
        manager.info(sys.argv[2])
    elif command == "search":
        query = sys.argv[2] if len(sys.argv) > 2 else None
        manager.search(query)
    else:
        print("Invalid command. Use 'ci' for help.")

if __name__ == "__main__":
    main()
'''
        
        with open(install_path, 'w') as f:
            f.write(ci_script)
    
    def ensure_path(self, bin_dir):
        """Ensure bin directory is in PATH"""
        bin_path = str(bin_dir)
        ci_bin_path = str(self.bin_dir)
        
        # Add both directories to PATH
        paths_to_add = [bin_path, ci_bin_path]
        
        shell_rc_files = [
            self.home / ".bashrc",
            self.home / ".zshrc", 
            self.home / ".profile"
        ]
        
        for rc_file in shell_rc_files:
            if rc_file.exists() or rc_file.name == ".bashrc":
                with open(rc_file, 'a') as f:
                    f.write(f'\n# CI Package Manager - AmerigoInc\n')
                    for path in paths_to_add:
                        f.write(f'export PATH="{path}:$PATH"\n')
                print(f"ğŸ“ Added CI to {rc_file.name}")
        
        print("ğŸ” Restart terminal or run: source ~/.bashrc")
    
    def run(self):
        """Main installation routine"""
        print("ğŸŒ CI Package Manager - AmerigoInc")
        print("=" * 50)
        print(f"ğŸ“¦ Packages source: {self.base_url}")
        print("")
        
        if self.install_ci_system():
            print("")
            print("ğŸ‰ Installation Complete!")
            print("ğŸ”§ Now use: ci install <package>")
            print("ğŸŒ Available anywhere in the system!")
            print("")
            print("Quick start:")
            print("  ci install <package-name>  # Install from AmerigoInc")
            print("  ci list                    # See installed packages")
            print("  ci --help                  # Show all commands")
        else:
            print("âŒ Installation failed")

def main():
    installer = CIInstaller()
    installer.run()

if __name__ == "__main__":
    main()
